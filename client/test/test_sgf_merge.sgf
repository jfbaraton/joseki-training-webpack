var sgf = require('smartgame');
var fs = require('fs');

var sansan_simple_haneSGF = String.raw`(;GM[1]FF[4]CA[UTF-8]AP[Sabaki:0.51.1]KM[7.5]SZ[19]DT[2022-12-08];B[pd];W[qc];B[qd];W[pc];B[oc];W[ob];B[nc])`;
var sansan_double_haneSGF = String.raw`(;GM[1]FF[4]CA[UTF-8]AP[Sabaki:0.51.1]KM[7.5]SZ[19]DT[2022-12-08];B[pd];W[qc];B[qd];W[pc];B[oc];W[ob];B[nb])`;

var sansan_simple_hane = sgf.parse(sansan_simple_haneSGF);
console.log('parsed sansan_simple_hane SGF: ', sansan_simple_hane);

var sansan_double_hane = sgf.parse(sansan_double_haneSGF);
console.log('parsed sansan_double_hane SGF: ', sansan_double_hane);

const isSameMove = function(node1, node2) {
	if (node1 === node2) return true;
	if (!node1 || !node2) return false;
	if (node1.pass && node2.pass) return true;
	if (node1.pass || node2.pass) return false;
	if (node1.B && node1.B === node2.B) return true;
	if (node1.W && node1.W === node2.W) return true;
	
	return false;
}

// everything from addedTree that is not already defined in masterTree will be added to masterTree
const merge = function(masterTree, addedTree, masterTreeNodeNextMoveIdx, addedTreeNodeNextMoveIdx) {
  let masterTreeNodePtr = masterTree;
  
  const isMasterNextMoveInMasterNodes = masterTree && masterTree.nodes && masterTree.nodes.length && masterTree.nodes.length > masterTreeNodeNextMoveIdx;
  
  if(!addedTree || !addedTree.nodes || !addedTree.nodes.length) return;
  // if the next node from addedTree is in nodes
  if(addedTree && addedTree.nodes && addedTree.nodes.length && addedTree.nodes.length> addedTreeNodeNextMoveIdx) {
	 // look for this addedTree node in the masterTree next node
	 if(isMasterNextMoveInMasterNodes) {
		if(isSameMove(masterTree.nodes[masterTreeNodeNextMoveIdx], addedTree.nodes[addedTreeNodeNextMoveIdx])) {
			// if master has this addTree node as the next node
			merge(masterTree, addedTree, masterTreeNodeNextMoveIdx+1, addedTreeNodeNextMoveIdx+1);
			return;
		} else {
			// nodes moves differ
			// both addTree node and master node become master sequences two options
			// save master.sequences to tmp
			let seqTMP = masterTree.sequences;
			masterTree.sequences = [];
			// master remaining nodes -> master.sequences[0]
			// seqTMP -> master.sequences[0].sequences
			
			// addTree remaining nodes -> master.sequences[1]
			// addTree.sequences -> master.sequences[1].sequences
			
			// check all parents
		}
	 } else if (masterTree.sequences && masterTree.sequences.length) {
		// next master move is in master.sequences
		
		// look in master.sequences if one corresponds
	 } else {
		// no move in master
		// add all remaining addTree.nodes at the end of master.nodes
		// addTree.sequences -> master.sequences
		
		// check all parents
	 }
	 
  } else if(addedTree.sequences && addedTree.sequences.length){
	// if the next node from addedTree is in sequences
	for(let addedTreeSeqIdx = 0; addedTreeSeqIdx < addedTree.sequences.length ; addedTreeSeqIdx ++ ) {
		const oneAddTreeSeq = addedTree.sequences[addedTreeSeqIdx];
		if(isMasterNextMoveInMasterNodes) {
			// if master has this sequence as the next node
			// -> add the addTree.sequences to master.seqences and remove master next node
			// check all parents
			// and that's it, no need to merge the rest of this addTree !!
			return;
		} else if (masterTree.sequences && masterTree.sequences.length && masterTree.sequences.some(
			oneMasterSeq => isSameMove(oneMasterSeq.nodes[0], oneAddTreeSeq.nodes[0]))){
			// if master has this sequence in its sequences
			// -> call recursively merge on those identical sequence nodes
			merge();
		} else {
			// master does not have this sequence 
			if() {
				// next master was is in master.nodes
				// -> add the addTree.sequences to master.seqences
				// -> transform the rest of master.nodes into an extra sequence (if not exist)
				// check all parents
				// and that's it, no need to merge the rest of this addTree !!
				return;
			} else if () {
				// next master was is in master.sequences
			} else {
				// there was no next master move
				// -> add the addTree.sequences to master.seqences
				// check all parents
				// and that's it, no need to merge the rest of this addTree !!
				return;
			}
		}
	}
  }
};

var mergedSGF = sgf.generate(sansan_simple_hane);
fs.writeFileSync('sansan_merged.sgf', mergedSGF, { encoding: 'utf8' });